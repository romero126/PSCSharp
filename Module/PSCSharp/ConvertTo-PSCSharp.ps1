function ConvertTo-PSCSharp
{
    [CmdletBinding()]
    param(
        [Parameter(Mandatory)]
        [System.String]$Path,
        
        [Parameter(Mandatory)]
        [System.String]$OutFile
    )
    begin
    {

    }
    process
    {
        if (-not (Test-Path -Path $Path -PathType Leaf))
        {
            throw "Could not find file"
        }

        # Get the AST of the file
        $tokens = $errors = $null
        $ast = [System.Management.Automation.Language.Parser]::ParseFile( $path, [ref]$tokens, [ref]$errors )
        # Get only function definition ASTs
        $functionDefinitions = $ast.FindAll({
            param([System.Management.Automation.Language.Ast] $Ast)
            $Ast -is [System.Management.Automation.Language.FunctionDefinitionAst] -and
            ($PSVersionTable.PSVersion.Major -lt 5 -or
            $Ast.Parent -IsNot [System.Management.Automation.Language.FunctionMemberAst])
        }, $false)

        & {
            "using System;"
            "using System.Collections;"
            "using System.Collections.Generic;"
            "using System.Management.Automation;"
            ""
            "/// Code Automatically Generated by {0}" -f $PSCmdlet.CommandRuntime
            ""
            "namespace x.Powershell.Commands"
            "{"
            foreach ($Function in $FunctionDefinitions)
            {
                $FXVerb, $FXNoun = $function.Name -Split "-"
                $FXVerbGroup = Get-Verb $FXVerb | % Group

                "`t/// <summary>"
                "`t/// {0}-{1} Cmdlet." -f $FXVerb, $FXNoun
                "`t/// </summary>"
                "`t[Cmdlet(Verbs{0}.{1}, `"{2}`")]" -f $FXVerbGroup, $FXVerb, $FXNoun
                "`tpublic sealed class {0}{1} : PSCmdlet" -f $FXVerb, $FXNoun
                "`t{"
                "`t"
                foreach ($Parameter in $Function.Body.ParamBlock.Parameters)
                {
                    
                    $ParameterName = $Parameter.Name.VariablePath.ToString()
                    "`t`t/// <summary>"
                    "`t`t/// Sets value for {0}" -f $ParameterName
                    "`t`t/// </summary>"
                    foreach ($Attribute in ($Parameter.Attributes | Select-Object -SkipLast 1))
                    {

                        $Param = $Attribute.NamedArguments | % {
                            $value = if ($_.ArgumentName -eq $_.Argument) { $_.ExpressionOmitted.ToString().ToLower() } else { $_.Argument }
                            "{0} = {1}" -f $_.ArgumentName, $Value
                        }

                        "`t`t[{0}({1})]" -f $Attribute.TypeName, ($Param -join ", ")
                    }

                    
                    "`t`tpublic $($Parameter.Attributes[-1].TypeName) ${ParameterName} { get; set; }"
                    "`t`t"
                }

                $Blocks = [Ordered]@{
                    'BeginProcessing'   = $Function.Body.BeginBlock
                    'ProcessRecord'     = $Function.Body.ProcessBlock
                    'EndProcessing'     = $Function.Body.EndBlock
                }
                foreach ($Block in $Blocks.GetEnumerator())
                {
                    "`t`t/// <summary>"
                    "`t`t/// {0}" -f $Block.Key
                    "`t`t/// </summary>"
                    "`t`tprotected override void {0}()" -f $Block.Key
                    "`t`t{"
                    "`t`t`t/// Code is not Generated Automatically you still need to program"
                    foreach ($AstItem in $Block.Value)
                    {
                        foreach ($PipelineElement in $AstItem.Statements.PipelineElements)
                        {
                            #Find Elements                 
                            $Result = Get-PSCSharpCommandAlias -Name $PipelineElement.CommandElements[0] -Elements ( $PipelineElement.CommandElements | Select -Skip 1 )

                            if (!$Result)
                            {
                                $Result = "// $PipelineElement"
                            }
                            "`t`t`t$Result"   
                        }

                    }
                    "`t`t}"
                    ""

                }

            }
            "`t}"
            "}"
        } | Out-File -FilePath $OutFile


    }
    end
    {

    }
}